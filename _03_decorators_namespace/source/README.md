# Checklist

- [ ] Decorators
  - [ ] Add support to `InvokeTSC.mts`
  - [ ] `const stitch = CrossStitchDecorators.getNamespace(name);`
  - [ ] `@stitch.componentKey(componentName: string)`
  - [ ] `@stitch.setsReturn(always: boolean)`
  - [ ] `@stitch.sequence`
  - [ ] `@stitch.current` symbol for "current class or sequence" to feed into `@stitch.sequence`
  - [ ] `@stitch.entryPoint`
  - [ ] `@stitch.renameToPrivate(fieldName, "method" | "property" | "readonly property")` for entryPoint
  - [ ] `@stitch.rewriteForPrivate(fieldName, ts-morph callback)` for entryPoint
  - [ ] README: tie these concepts to aspect-oriented programming models
- [ ] TypeScript-ESLint to check properties for conflicts
  - [ ] Helper module to invoke these rules (until I can export them)
  - [ ] method names are unique except for those in the specified class type
  - [ ] setReturnType is callable only once per method (and that when `@mayReturn` is on the class)
  - [ ] Always require `return setReturnType(...);`
  - [ ] getReturnType is only called in the entry class
  - [ ] Component class methods must have a return type of void
  - [ ] Component class methods never have a return statement
  - [ ] Invoke helper module as a build step
  - [ ] Optional: overwriting modifiedArguments
  - [ ] Overwriting parameter arguments when someone overwrites modifiedArguments elsewhere
    - Is this even possible with eslint?  Multiple files is not their strength.
- [ ] Some sanity check that a `@setsReturn`-annotated class forces the return type to be set
  - [ ] Maybe by a forced ts-morph on a temporary copy, and InvokeTSC?
